# Keycloak Cross-Realm Session Leakage Vulnerability

## Summary
A critical vulnerability exists in Keycloak's persistent session management that allows potential cross-realm session access due to insufficient realm validation in the session retrieval process.

## Vulnerability Details

### Root Cause
Session entities are retrieved from cache by key **before** realm validation occurs, creating a timing window where cross-realm session data can be accessed.

### Affected Files
1. `PersistentSessionsChangelogBasedTransaction.java` - Line 113: Direct cache access without realm validation
2. `UserSessionPersistentChangelogBasedTransaction.java` - Lines 59-77: Timing window between cache retrieval and validation  
3. `ClientSessionPersistentChangelogBasedTransaction.java` - Similar pattern in client session handling

### Attack Vector
1. Attacker in Realm A discovers session keys from Realm B (through timing attacks, logs, or other means)
2. Attacker crafts requests using Realm B session keys
3. During the timing window (lines 59-77), session data from Realm B is temporarily accessible
4. Even though validation eventually fails, sensitive session data has already been loaded into memory

### Impact
- **Cross-tenant data exposure** in multi-tenant environments
- **Session hijacking** across realm boundaries  
- **Privilege escalation** by accessing higher-privileged realm sessions
- **Information disclosure** of session metadata from other realms

## Technical Analysis

### Vulnerable Code Pattern
```java
// VULNERABLE: Cache access without realm validation
SessionEntityWrapper<V> wrappedEntity = getCache(offline).get(key);

// Session data is now in memory and accessible
wrappedEntity.getEntity().setOffline(offline);

// Validation happens AFTER data access (too late)
RealmModel realmFromSession = kcSession.realms().getRealm(wrappedEntity.getEntity().getRealmId());
if (!realmFromSession.getId().equals(realm.getId())) {
    return null; // Data already exposed
}
```

### Why This Vulnerability Requires Codebase Context
- Requires understanding of Keycloak's multi-tenant architecture
- Knowledge of session caching mechanisms across realms
- Understanding of the timing between cache access and validation
- Familiarity with session key generation patterns

## Proof of Concept
This vulnerability can be exploited by:
1. Monitoring session access patterns across realms
2. Identifying shared cache key patterns
3. Exploiting the timing window in concurrent session operations
4. Accessing session metadata before validation rejects the request

## Recommended Fix
Implement realm-scoped cache keys or validate realm before cache access:

```java
// Option 1: Realm-scoped cache keys
String realmScopedKey = realm.getId() + ":" + key;
SessionEntityWrapper<V> wrappedEntity = getCache(offline).get(realmScopedKey);

// Option 2: Early realm validation
if (!isValidRealmForKey(realm, key)) {
    return null;
}
SessionEntityWrapper<V> wrappedEntity = getCache(offline).get(key);
```